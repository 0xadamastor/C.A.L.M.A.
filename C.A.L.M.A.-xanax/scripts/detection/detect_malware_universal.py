import sys
import os
import json
import pickle
import warnings
from pathlib import Path
from dataclasses import dataclass
from typing import Tuple, Optional, TYPE_CHECKING

import numpy as np
import pandas as pd

warnings.filterwarnings('ignore')

if TYPE_CHECKING:
    from virustotal_api import VTDetectionResult

                   
BASE_DIR = Path(__file__).parent
MODEL_PE_PATH = BASE_DIR / "Data/modelo_malware.pkl"
SCALER_PE_PATH = BASE_DIR / "Data/scaler_malware.pkl"
MODEL_PDF_PATH = BASE_DIR / "Data/modelo_pdf.pkl"
SCALER_PDF_PATH = BASE_DIR / "Data/scaler_pdf.pkl"
ENCODERS_PDF_PATH = BASE_DIR / "Data/encoders_pdf.pkl"

                        
try:
    import pefile
    PEFILE_AVAILABLE = True
except ImportError:
    PEFILE_AVAILABLE = False

try:
    import PyPDF2
    PYPDF2_AVAILABLE = True
except ImportError:
    PYPDF2_AVAILABLE = False


@dataclass
class DetectionResult:
    file_path: str
    file_type: str                                           
    method: str                            
    prediction: str                            
    score: int         
    probability_malware: float           
    risk_level: str                                      
    confidence: float
    details: str
    virustotal_result: Optional['VTDetectionResult'] = None
    
    def __str__(self):
        emoji = "" if self.prediction == "LIMPO" else ("️" if self.prediction == "SUSPEITO" else "")
        
        return f"""
╔══════════════════════════════════════════════════════════╗
║            DETECÇÃO UNIVERSAL DE MALWARE                 ║
╠══════════════════════════════════════════════════════════╣
║ {emoji} RESULTADO: {self.prediction:<43} ║
╠══════════════════════════════════════════════════════════╣
║ Ficheiro:  {self.file_path:<45} ║
║ Tipo:      {self.file_type:<45} ║
║ Método:    {self.method:<45} ║
║                                                          ║
║ SCORE DE RISCO: {self.score:3}/100                                    ║
║ Nível:          {self.risk_level:<43} ║
║                                                          ║
║ Probabilidade Malware: {self.probability_malware:6.2%}                       ║
║ Confiança:             {self.confidence:6.2%}                       ║
║                                                          ║
║ Detalhes: {self.details:<44} ║
╚══════════════════════════════════════════════════════════╝
"""


def detect_file_type(file_path: str) -> Tuple[str, str]:
    path = Path(file_path)
    ext = path.suffix.lower()
    
                                       
    try:
        with open(file_path, 'rb') as f:
            header = f.read(8)
    except:
        return 'OTHER', 'Não foi possível ler ficheiro'
    
                              
    if header[:2] == b'MZ':
        return 'PE', f'Executável Windows ({ext})'
    
         
    if header[:4] == b'%PDF':
        return 'PDF', f'Documento PDF ({ext})'
    
                                  
    if header[:2] == b'PK':
        if ext in ['.docx', '.xlsx', '.pptx']:
            return 'OFFICE', f'Microsoft Office {ext}'
        elif ext == '.jar':
            return 'ARCHIVE', 'Java Archive (JAR)'
        elif ext == '.apk':
            return 'ARCHIVE', 'Android Package (APK)'
        else:
            return 'ARCHIVE', f'Arquivo comprimido ({ext})'
    
         
    if header[:4] == b'Rar!':
        return 'ARCHIVE', 'Arquivo RAR'
    
        
    if header[:6] == b'7z\xbc\xaf\x27\x1c':
        return 'ARCHIVE', 'Arquivo 7-Zip'
    
                             
    if header[:4] == b'\x7fELF':
        return 'PE', 'Executável Linux (ELF)'
    
                                 
    script_exts = {
        '.py': 'Python Script',
        '.sh': 'Shell Script',
        '.bat': 'Batch Script',
        '.cmd': 'Windows Command Script',
        '.ps1': 'PowerShell Script',
        '.vbs': 'VBScript',
        '.js': 'JavaScript',
        '.jar': 'Java Archive',
        '.pl': 'Perl Script',
        '.rb': 'Ruby Script',
        '.php': 'PHP Script'
    }
    if ext in script_exts:
        return 'SCRIPT', script_exts[ext]
    
                   
    office_exts = {
        '.doc': 'Microsoft Word (legado)',
        '.xls': 'Microsoft Excel (legado)',
        '.ppt': 'Microsoft PowerPoint (legado)',
        '.rtf': 'Rich Text Format'
    }
    if ext in office_exts:
        return 'OFFICE', office_exts[ext]
    
             
    if header[:2] == b'\xff\xd8':
        return 'IMAGE', 'Imagem JPEG'
    if header[:8] == b'\x89PNG\r\n\x1a\n':
        return 'IMAGE', 'Imagem PNG'
    if header[:3] == b'GIF':
        return 'IMAGE', 'Imagem GIF'
    
    return 'OTHER', f'Tipo desconhecido ({ext})'


def analyze_pe_ml(file_path: str) -> Tuple[int, float, str]:
    if not PEFILE_AVAILABLE:
        return 50, 0.5, "pefile não instalado - usando fallback"
    
    if not MODEL_PE_PATH.exists():
        return 50, 0.5, "Modelo PE não treinado"
    
    try:
                                       
        from extract_pe_features import extract_pe_features
        
                         
        with open(MODEL_PE_PATH, 'rb') as f:
            model = pickle.load(f)
        with open(SCALER_PE_PATH, 'rb') as f:
            scaler = pickle.load(f)
        
                          
        features = extract_pe_features(file_path)
        features_input = features[:53] + features[54:]                             
        
                             
        features_scaled = scaler.transform([features_input])
        prob_malware = model.predict_proba(features_scaled)[0][1]
        score = int(prob_malware * 100)
        
        return score, prob_malware, f"Modelo ML-PE (accuracy 94.64%)"
        
    except Exception as e:
        return 50, 0.5, f"Erro ML-PE: {str(e)[:30]}"


def analyze_pdf_ml(file_path: str) -> Tuple[int, float, str]:
    if not MODEL_PDF_PATH.exists():
        return 50, 0.5, "Modelo PDF não treinado"
    
    try:
                                           
        from extract_pdf_features import extract_pdf_features
        
                         
        with open(MODEL_PDF_PATH, 'rb') as f:
            model = pickle.load(f)
        with open(SCALER_PDF_PATH, 'rb') as f:
            scaler = pickle.load(f)
        with open(ENCODERS_PDF_PATH, 'rb') as f:
            encoders = pickle.load(f)
        
                          
        features_dict = extract_pdf_features(file_path)
        
                              
        df_sample = pd.DataFrame([features_dict])
        X = df_sample.drop(columns=['name', 'class'], errors='ignore')
        
                             
        for col, encoder in encoders.items():
            if col in X.columns:
                X[col] = encoder.transform(X[col].astype(str))
        
                             
        X_scaled = scaler.transform(X)
        prob_malware = model.predict_proba(X_scaled)[0][1]
        score = int(prob_malware * 100)
        
        return score, prob_malware, f"Modelo ML-PDF (accuracy 97.84%)"
        
    except Exception as e:
        return 50, 0.5, f"Erro ML-PDF: {str(e)[:30]}"


def analyze_heuristic(file_path: str, file_type: str) -> Tuple[int, float, str]:
    try:
                               
        from score_risco import assess_risk
        
        result = assess_risk(file_path)
        score = result.final_score
        probability = score / 100.0
        
        signals = [f"{s.name}={s.value}" for s in result.signals if s.value > 0]
        details = f"Heurística v2.0: {', '.join(signals[:3])}"
        
        return score, probability, details
        
    except Exception as e:
                                                                
        path = Path(file_path)
        ext = path.suffix.lower()
        size = path.stat().st_size
        
        score = 30                    
        
                                   
        dangerous_exts = ['.exe', '.scr', '.pif', '.com', '.bat', '.cmd', '.vbs', '.js', '.jar', '.ps1']
        if ext in dangerous_exts:
            score += 30
        
                 
        if file_type == 'SCRIPT':
            score += 20
        
                                                     
        if file_type == 'ARCHIVE':
            score += 10
        
                                                          
        if size < 1024:         
            score += 15
        elif size > 10 * 1024 * 1024:          
            score += 10
        
        score = min(score, 100)
        probability = score / 100.0
        
        return score, probability, f"Análise básica ({ext}, {size} bytes)"


def calculate_risk_level(score: int) -> str:
                                                        
    if score < 20:
        return "LIMPO"
    elif score < 40:
        return "BAIXO"
    elif score < 65:
        return "MÉDIO"
    elif score < 85:
        return "ALTO"
    else:
        return "CRÍTICO"


def calculate_classification(score: int) -> str:
                      
    if score < 50:
        return "LIMPO"
    elif score < 75:
        return "SUSPEITO"
    else:
        return "MALWARE"


def detect_malware(file_path: str, use_virustotal: bool = True, config_file: Optional[str] = None) -> DetectionResult:
    """
    Detecta malware usando VirusTotal como primeira opção, depois fallback para análise local
    
    Args:
        file_path: Caminho do ficheiro
        use_virustotal: Se deve usar VirusTotal
        config_file: Caminho do ficheiro de configuração
        
    Returns:
        DetectionResult
    """
    if not Path(file_path).exists():
        raise FileNotFoundError(f"Ficheiro não encontrado: {file_path}")
    
    virustotal_result = None
    
    # Tenta VirusTotal primeiro se habilitado
    if use_virustotal:
        try:
            from virustotal_api import get_virustotal_client, VTDetectionResult
            
            if config_file is None:
                config_file = Path(__file__).parent.parent.parent / "config" / "calma_config.json"
            
            # Carrega configuração
            with open(config_file) as f:
                config = json.load(f)
            
            if config.get('virustotal_enabled', False):
                try:
                    client = get_virustotal_client(config_file)
                    file_hash, virustotal_result = client.scan_file(file_path)
                    
                    # Se VirusTotal teve sucesso, usa seu resultado
                    if virustotal_result and not virustotal_result.error:
                        # Converte resultado do VirusTotal para nossa escala
                        if virustotal_result.is_malicious:
                            # Malicioso detectado por múltiplos antivírus
                            score = 90 + min(10, virustotal_result.malicious_count)  # 90-100
                            classification = "MALWARE"
                            method = "VirusTotal (Sandbox)"
                        else:
                            # Nenhum antivírus detectou
                            score = max(0, 20 - virustotal_result.undetected_count)  # 0-20
                            classification = "LIMPO"
                            method = "VirusTotal (Verified Clean)"
                        
                        risk_level = calculate_risk_level(score)
                        confidence = 0.95  # VirusTotal tem alta confiabilidade
                        probability = virustotal_result.malicious_count / max(virustotal_result.total_vendors, 1)
                        
                        details = f"{virustotal_result.malicious_count} detecções de {virustotal_result.total_vendors} antivírus"
                        
                        return DetectionResult(
                            file_path=file_path,
                            file_type=detect_file_type(file_path)[1],
                            method=method,
                            prediction=classification,
                            score=score,
                            probability_malware=probability,
                            risk_level=risk_level,
                            confidence=confidence,
                            details=details,
                            virustotal_result=virustotal_result
                        )
                    else:
                        print(f"[CALMA] [AVISO] VirusTotal erro: {virustotal_result.error if virustotal_result else 'Desconhecido'}")
                        print(f"[CALMA] Usando analise local como fallback...")
                
                except ValueError as e:
                    print(f"[CALMA] [AVISO] {e}")
                    print(f"[CALMA] Continuando com analise local...")
                except ImportError:
                    print(f"[CALMA] [AVISO] Modulo requests nao instalado. Instale com: pip install requests")
                    print(f"[CALMA] Usando analise local como fallback...")
                except Exception as e:
                    print(f"[CALMA] [AVISO] Erro VirusTotal: {e}")
                    print(f"[CALMA] Usando analise local como fallback...")
        
        except Exception as e:
            print(f"[CALMA] [AVISO] Erro ao inicializar VirusTotal: {e}")
    
    # Análise local (fallback)
    print(f"\n[CALMA] Executando análise local...")
    
    file_type, type_details = detect_file_type(file_path)
    
    if file_type == 'PE':
        score, prob_malware, details = analyze_pe_ml(file_path)
        method = "ML-PE"
    elif file_type == 'PDF':
        score, prob_malware, details = analyze_pdf_ml(file_path)
        method = "ML-PDF"
    else:
        score, prob_malware, details = analyze_heuristic(file_path, file_type)
        method = "HEURISTIC"
    
    classification = calculate_classification(score)
    risk_level = calculate_risk_level(score)
    confidence = max(prob_malware, 1 - prob_malware)
    
    return DetectionResult(
        file_path=file_path,
        file_type=type_details,
        method=method,
        prediction=classification,
        score=score,
        probability_malware=prob_malware,
        risk_level=risk_level,
        confidence=confidence,
        details=details,
        virustotal_result=virustotal_result
    )


def main():
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(1)
    
    file_path = sys.argv[1]
    score_only = '--score-only' in sys.argv
    verbose = '--verbose' in sys.argv
    
    try:
        result = detect_malware(file_path)
        
        if score_only:
                                                 
            print(result.score)
        elif verbose:
                             
            print(result)
            print(f"\n[DEBUG] Tipo detectado: {result.file_type}")
            print(f"[DEBUG] Método usado: {result.method}")
            print(f"[DEBUG] Detalhes: {result.details}")
        else:
                           
            emoji = "" if result.prediction == "LIMPO" else ("️" if result.prediction == "SUSPEITO" else "")
            print(f"\n{emoji} {result.prediction}")
            print(f"   Tipo:   {result.file_type}")
            print(f"   Método: {result.method}")
            print(f"   Score:  {result.score}/100")
            print(f"   Nível:  {result.risk_level}")
    
    except Exception as e:
        print(f" Erro: {e}")
        if verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
